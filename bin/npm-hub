import { readFileSync, writeFileSync } from 'fs';
import { resolve, resolve as r } from 'path';
import glob from 'glob';
import terser from 'terser';
import bundle from 'webpack';
import m from 'moment';

// -------------- Fix --------------
const { sync } = glob;
const { minify } = terser;
const [__dirname, dir] = [, ,].fill(resolve());

const BUNDLE_FILE_NAME = 'bundle.js';
const LINE = '--------------';
const ERR = '`argv` are invalid!';
const UTF = 'utf8';
const F = 'DD-MM-YYYY HH:mm:ss:SS';
const { argv, exit } = process;

class VerHandling {
  static Verify(argv) {
    if (argv.find(x => x === 'v' || x === '--v')) { // `v` Might be Temp
      const readFile = readFileSync('./package.json', UTF);
      const { version: v } = JSON.parse(readFile);
      console.log(`v` + v);

      exit();
    }
  }
}

class TypeHandling {
  static Verify(argv) {
    if (!argv) throw new Error(ERR);

    const type = argv.find(x => x.startsWith('--type='));

    if (!type) throw new Error(ERR);

    return type.replace('--type=', '');
  }
}

class FG {
  static get Blue() {
    return `\x1b[36m`;
  }

  static get Default() {
    return `\x1b[0m`;
  }
}

// ...

VerHandling.Verify(argv);
const type = TypeHandling.Verify(argv);
const allJ = sync('./dist/*.js');

// ...

const finalizeFn = () => console.log(LINE, 'END  ', FG.Blue, m().format(F)
  , FG.Default, LINE);

const pathFile = (path, filename) => ({ path: r(dir, path), filename });

const minifyFn = () => {
  const filterAllJ = allJ.filter(x => !x.includes(BUNDLE_FILE_NAME))
    .filter(x => !x.endsWith('.spec.js'));

  filterAllJ.forEach(x => {
    const readFile = minify(readFileSync(x, UTF), {}).code;

    writeFileSync(x, readFile, UTF);
  });

  finalizeFn();
};

const bundleFn = type => {
  const igniteFn = prepareBundle => prepareBundle.run(_ => finalizeFn());

  switch (type) {
    case 'bundle': {
      const entry = allJ.filter(x => !x.includes(BUNDLE_FILE_NAME))
        .filter(x => !x.endsWith('.spec.js'));

      const prepareBundle = bundle({
        mode: 'production',
        entry,
        output: {
          ...pathFile('bundle', BUNDLE_FILE_NAME),
          library: 'ntn_try_me',
          libraryTarget: 'var'
        }
      });

      return igniteFn(prepareBundle);
    }
    case 'bundleDev': {
      const entry = allJ.filter(x => !x.includes(BUNDLE_FILE_NAME));

      const prepareBundle = bundle({
        mode: 'production',
        entry,
        output: {
          ...pathFile('dist/dev', BUNDLE_FILE_NAME),
          library: 'ntn_try_me',
          libraryTarget: 'var'
        }
      });

      return igniteFn(prepareBundle);
    }
  }
};

// ...

console.log(LINE, 'BEGIN', FG.Blue, m().format(F)
  , FG.Default, LINE);

switch (type) {
  case 'minify':
    minifyFn();
    break;
  case 'bundle':
  case 'bundleDev':
    bundleFn(type);
    break;
  default:
    throw new Error(ERR);
}
